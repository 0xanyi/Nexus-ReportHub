 import { describe, it, expect } from "vitest"
 import type { CampaignCategorySummary } from "../campaigns"
 
 /**
  * Unit tests for campaign aggregation logic.
  * Tests pure transformation logic that can be extracted from the main function.
  */
 
 describe("Campaign Aggregation Logic", () => {
   describe("Date range validation", () => {
     it("should validate FY date range boundaries correctly", () => {
       const fyStart = new Date(Date.UTC(2024, 11, 1)) // Dec 1, 2024
       const fyEnd = new Date(Date.UTC(2025, 10, 30, 23, 59, 59, 999)) // Nov 30, 2025
       
       expect(fyStart < fyEnd).toBe(true)
       expect(fyStart.getUTCFullYear()).toBe(2024)
       expect(fyStart.getUTCMonth()).toBe(11) // December (0-indexed)
       expect(fyEnd.getUTCFullYear()).toBe(2025)
       expect(fyEnd.getUTCMonth()).toBe(10) // November (0-indexed)
     })
 
     it("should correctly identify dates within FY range", () => {
       const fyStart = new Date(Date.UTC(2024, 11, 1))
       const fyEnd = new Date(Date.UTC(2025, 10, 30, 23, 59, 59, 999))
       
       const withinRange = new Date(Date.UTC(2025, 5, 15)) // June 15, 2025
       const beforeRange = new Date(Date.UTC(2024, 10, 30)) // Nov 30, 2024
       const afterRange = new Date(Date.UTC(2025, 11, 1)) // Dec 1, 2025
       
       expect(withinRange >= fyStart && withinRange <= fyEnd).toBe(true)
       expect(beforeRange >= fyStart).toBe(false)
       expect(afterRange <= fyEnd).toBe(false)
     })
   })
 
   describe("Amount aggregation", () => {
     it("should handle various amount formats correctly", () => {
       const amounts = [100, 50.5, 25.25, 0]
       const total = amounts.reduce((sum, amt) => sum + amt, 0)
       expect(total).toBe(175.75)
     })
 
     it("should skip NaN and non-finite amounts", () => {
       const amounts = [100, NaN, Infinity, -Infinity, 50]
       const validAmounts = amounts.filter(amt => Number.isFinite(amt) && amt !== 0)
       const total = validAmounts.reduce((sum, amt) => sum + amt, 0)
       expect(total).toBe(150)
     })
 
     it("should skip zero amounts", () => {
       const amounts = [100, 0, 50, 0, 25]
       const validAmounts = amounts.filter(amt => Number.isFinite(amt) && amt !== 0)
       expect(validAmounts).toEqual([100, 50, 25])
     })
   })
 
   describe("Hierarchy sorting", () => {
     it("should sort by totalAmount descending", () => {
       const items = [
         { name: "A", totalAmount: 100 },
         { name: "B", totalAmount: 300 },
         { name: "C", totalAmount: 200 },
       ]
       const sorted = [...items].sort((a, b) => b.totalAmount - a.totalAmount)
       expect(sorted[0].name).toBe("B")
       expect(sorted[1].name).toBe("C")
       expect(sorted[2].name).toBe("A")
     })
   })
 
   describe("Summary structure validation", () => {
     it("should validate CampaignCategorySummary structure", () => {
       const summary: CampaignCategorySummary = {
         id: "test-id",
         name: "Test Campaign",
         normalizedName: "test_campaign",
         autoGenerated: false,
         totalAmount: 1000,
         paymentCount: 10,
         zoneTotals: [
           { id: "zone-1", name: "Zone 1", totalAmount: 600 },
           { id: "zone-2", name: "Zone 2", totalAmount: 400 },
         ],
         groups: [
           {
             id: "group-1",
             name: "Group 1",
             zoneId: "zone-1",
             zoneName: "Zone 1",
             totalAmount: 600,
             churches: [
               { id: "church-1", name: "Church 1", totalAmount: 350 },
               { id: "church-2", name: "Church 2", totalAmount: 250 },
             ],
           },
         ],
       }
 
       expect(summary.id).toBe("test-id")
       expect(summary.zoneTotals).toHaveLength(2)
       expect(summary.groups[0].churches).toHaveLength(2)
       expect(summary.zoneTotals[0].totalAmount + summary.zoneTotals[1].totalAmount).toBe(1000)
     })
   })
 })
