import { NextRequest, NextResponse } from "next/server"
import { auth } from "@/auth"
import { prisma } from "@/lib/prisma"
import { z } from "zod"
import { getFinancialYearFromParam } from "@/lib/financialYear"
import { requireAuth, requireAdmin } from "@/lib/auth-guards"
import { requireCsrf } from "@/lib/csrf"

const createCampaignSchema = z.object({
  name: z.string().min(1, "Campaign name is required").max(255),
  departmentId: z.string().min(1, "Department is required"),
  autoGenerated: z.boolean().optional().default(false),
})

export async function GET(request: NextRequest) {
  try {
    const session = await auth()

    const authCheck = requireAuth(session)
    if (!authCheck.authorized) {
      return NextResponse.json({ error: authCheck.error }, { status: authCheck.status })
    }

    const { searchParams } = new URL(request.url)
    const fyParam = searchParams.get("fy") ?? undefined

    const fyBounds = await getFinancialYearFromParam(fyParam, prisma)
    const fyStartDate = fyBounds?.startDate
    const fyEndDate = fyBounds?.endDate

    const dateFilter =
      fyStartDate && fyEndDate ? { paymentDate: { gte: fyStartDate, lte: fyEndDate } } : {}

    const campaigns = await prisma.campaignCategory.findMany({
      include: {
        department: {
          select: {
            id: true,
            name: true,
          },
        },
        _count: {
          select: {
            payments: { where: dateFilter },
          },
        },
        payments: {
          where: dateFilter,
          select: {
            amount: true,
          },
        },
      },
      orderBy: [
        { autoGenerated: "asc" },
        { name: "asc" },
      ],
    })

    const campaignsWithTotals = campaigns.map((campaign) => {
      const totalAmount = campaign.payments.reduce((sum, payment) => {
        return sum + Number(payment.amount)
      }, 0)

      return {
        id: campaign.id,
        name: campaign.name,
        normalizedName: campaign.normalizedName,
        autoGenerated: campaign.autoGenerated,
        department: campaign.department,
        paymentCount: campaign._count.payments,
        totalAmount,
        createdAt: campaign.createdAt,
        updatedAt: campaign.updatedAt,
      }
    })

    return NextResponse.json(campaignsWithTotals)
  } catch (error) {
    console.error("Error fetching campaigns:", error)
    return NextResponse.json(
      { error: "Failed to fetch campaigns" },
      { status: 500 }
    )
  }
}

export async function POST(request: Request) {
  try {
    const session = await auth()

    // CSRF validation
    const csrfError = await requireCsrf()
    if (csrfError) return csrfError

    // Auth and role check
    const authCheck = requireAdmin(session)
    if (!authCheck.authorized) {
      return NextResponse.json({ error: authCheck.error }, { status: authCheck.status })
    }

    const body = await request.json()
    const validatedData = createCampaignSchema.parse(body)

    const normalizedName = validatedData.name
      .toLowerCase()
      .trim()
      .replace(/\s+/g, "_")

    const existingCampaign = await prisma.campaignCategory.findUnique({
      where: {
        departmentId_normalizedName: {
          departmentId: validatedData.departmentId,
          normalizedName,
        },
      },
    })

    if (existingCampaign) {
      return NextResponse.json(
        { error: "A campaign with this name already exists in the department" },
        { status: 409 }
      )
    }

    const campaign = await prisma.campaignCategory.create({
      data: {
        name: validatedData.name,
        normalizedName,
        autoGenerated: validatedData.autoGenerated,
        departmentId: validatedData.departmentId,
      },
      include: {
        department: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    })

    return NextResponse.json(campaign, { status: 201 })
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Invalid request data", details: error.issues },
        { status: 400 }
      )
    }

    console.error("Error creating campaign:", error)
    return NextResponse.json(
      { error: "Failed to create campaign" },
      { status: 500 }
    )
  }
}
