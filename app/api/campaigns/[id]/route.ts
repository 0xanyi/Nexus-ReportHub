import { NextResponse } from "next/server"
import { auth } from "@/auth"
import { prisma } from "@/lib/prisma"
import { requireAuth, requireAdmin } from "@/lib/auth-guards"
import { requireCsrf } from "@/lib/csrf"
import { z } from "zod"

const updateCampaignSchema = z.object({
  name: z.string().min(1, "Campaign name is required").max(255).optional(),
  autoGenerated: z.boolean().optional(),
})

export async function GET(
  request: Request,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const session = await auth()

    const authCheck = requireAuth(session)
    if (!authCheck.authorized) {
      return NextResponse.json({ error: authCheck.error }, { status: authCheck.status })
    }

    const { id } = await context.params

    // Parse pagination parameters from query string
    const url = new URL(request.url)
    const skip = Math.max(0, parseInt(url.searchParams.get("skip") || "0", 10))
    const take = Math.min(500, Math.max(1, parseInt(url.searchParams.get("take") || "100", 10)))

    const campaign = await prisma.campaignCategory.findUnique({
      where: { id },
      include: {
        department: {
          select: {
            id: true,
            name: true,
          },
        },
        payments: {
          skip,
          take,
          include: {
            church: {
              include: {
                group: {
                  include: {
                    zone: true,
                  },
                },
              },
            },
          },
          orderBy: {
            paymentDate: "desc",
          },
        },
        _count: {
          select: {
            payments: true,
          },
        },
      },
    })

    if (!campaign) {
      return NextResponse.json({ error: "Campaign not found" }, { status: 404 })
    }

    const zoneTotals = new Map<string, { id: string; name: string; total: number }>()
    const groupTotals = new Map<string, {
      id: string
      name: string
      zoneName: string
      total: number
      churches: Map<string, { id: string; name: string; total: number }>
    }>()

    let totalAmount = 0

    for (const payment of campaign.payments) {
      const amount = Number(payment.amount)
      totalAmount += amount

      const church = payment.church
      const group = church?.group
      const zone = group?.zone

      if (!church || !group || !zone) continue

      if (!zoneTotals.has(zone.id)) {
        zoneTotals.set(zone.id, { id: zone.id, name: zone.name, total: 0 })
      }
      zoneTotals.get(zone.id)!.total += amount

      if (!groupTotals.has(group.id)) {
        groupTotals.set(group.id, {
          id: group.id,
          name: group.name,
          zoneName: zone.name,
          total: 0,
          churches: new Map(),
        })
      }

      const groupEntry = groupTotals.get(group.id)!
      groupEntry.total += amount

      if (!groupEntry.churches.has(church.id)) {
        groupEntry.churches.set(church.id, { id: church.id, name: church.name, total: 0 })
      }

      groupEntry.churches.get(church.id)!.total += amount
    }

    const zoneBreakdown = Array.from(zoneTotals.values())
      .sort((a, b) => b.total - a.total)

    const groupBreakdown = Array.from(groupTotals.values()).map((group) => ({
      id: group.id,
      name: group.name,
      zoneName: group.zoneName,
      total: group.total,
      churches: Array.from(group.churches.values()).sort((a, b) => b.total - a.total),
    })).sort((a, b) => b.total - a.total)

    return NextResponse.json({
      id: campaign.id,
      name: campaign.name,
      normalizedName: campaign.normalizedName,
      autoGenerated: campaign.autoGenerated,
      department: campaign.department,
      totalAmount,
      paymentCount: campaign._count.payments,
      currentPagePayments: campaign.payments.length,
      totalPayments: campaign._count.payments,
      pagination: {
        skip,
        take,
        hasMore: skip + campaign.payments.length < campaign._count.payments,
      },
      zoneBreakdown,
      groupBreakdown,
      createdAt: campaign.createdAt,
      updatedAt: campaign.updatedAt,
    })
  } catch (error) {
    console.error("Error fetching campaign:", error)
    return NextResponse.json(
      { error: "Failed to fetch campaign" },
      { status: 500 }
    )
  }
}

export async function PATCH(
  request: Request,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const session = await auth()

    // CSRF validation
    const csrfError = await requireCsrf()
    if (csrfError) return csrfError

    // Auth and role check
    const authCheck = requireAdmin(session)
    if (!authCheck.authorized) {
      return NextResponse.json({ error: authCheck.error }, { status: authCheck.status })
    }

    const { id } = await context.params
    const body = await request.json()
    const validatedData = updateCampaignSchema.parse(body)

    const existingCampaign = await prisma.campaignCategory.findUnique({
      where: { id },
    })

    if (!existingCampaign) {
      return NextResponse.json({ error: "Campaign not found" }, { status: 404 })
    }

    const updateData: {
      name?: string
      normalizedName?: string
      autoGenerated?: boolean
    } = {}

    if (validatedData.name !== undefined) {
      updateData.name = validatedData.name
      updateData.normalizedName = validatedData.name
        .toLowerCase()
        .trim()
        .replace(/\s+/g, "_")

      const conflictingCampaign = await prisma.campaignCategory.findFirst({
        where: {
          departmentId: existingCampaign.departmentId,
          normalizedName: updateData.normalizedName,
          id: { not: id },
        },
      })

      if (conflictingCampaign) {
        return NextResponse.json(
          { error: "A campaign with this name already exists in the department" },
          { status: 409 }
        )
      }
    }

    if (validatedData.autoGenerated !== undefined) {
      updateData.autoGenerated = validatedData.autoGenerated
    }

    const campaign = await prisma.campaignCategory.update({
      where: { id },
      data: updateData,
      include: {
        department: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    })

    return NextResponse.json(campaign)
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Invalid request data", details: error.issues },
        { status: 400 }
      )
    }

    console.error("Error updating campaign:", error)
    return NextResponse.json(
      { error: "Failed to update campaign" },
      { status: 500 }
    )
  }
}

export async function DELETE(
  request: Request,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const session = await auth()

    // CSRF validation
    const csrfError = await requireCsrf()
    if (csrfError) return csrfError

    // Auth and role check
    const authCheck = requireAdmin(session)
    if (!authCheck.authorized) {
      return NextResponse.json({ error: authCheck.error }, { status: authCheck.status })
    }

    const { id } = await context.params

    const campaign = await prisma.campaignCategory.findUnique({
      where: { id },
      include: {
        _count: {
          select: {
            payments: true,
          },
        },
      },
    })

    if (!campaign) {
      return NextResponse.json({ error: "Campaign not found" }, { status: 404 })
    }

    if (campaign._count.payments > 0) {
      return NextResponse.json(
        {
          error: `Cannot delete campaign with ${campaign._count.payments} payment(s). ` +
            "Please remove or reassign payments first.",
        },
        { status: 400 }
      )
    }

    await prisma.campaignCategory.delete({
      where: { id },
    })

    return NextResponse.json({ message: "Campaign deleted successfully" })
  } catch (error) {
    console.error("Error deleting campaign:", error)
    return NextResponse.json(
      { error: "Failed to delete campaign" },
      { status: 500 }
    )
  }
}
